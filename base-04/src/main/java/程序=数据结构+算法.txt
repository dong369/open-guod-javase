我觉得比起问项目经验、问那些搜索一下就能搜到答案的吹牛皮题目，问算法题要靠谱得多。
第一部分：数据结构data structure（逻辑结构+存储结构），数据之间相互存在一种或多种特定的关系的元素的集合。
    存储（物理）结构：顺序存储、链式存储
    逻辑结构：线性结构、集合结构、树结构、图形结构
    ch01：数组+有序数组（查找快，因为存在index值，有序数组插入数据和删除数据太慢，涉及到数组的扩容）+二分法查找
    ch02：栈
        01：什么是栈：
        02：栈的特点：先进后出，后进先出。
        03：优点缺点：
        04：属性：
        05：功能：
    ch03：队列
        01什么是队列：
        02队列的特点：先进先出，后进后出。
        03：优点缺点：
    ch04：链表
        01什么是链表：
        02链表的特点：
        03：优点缺点：链表查找数据太慢，插入数据和删除数据太快。
    ch05：双端链表
        01什么是双端链表：链表中保存着对最后一个链节点引用的链表。
        02从头部进行插入操作（要对链表进行判断，如果为空，则设置尾节点为新添加的节点）
        03从尾部进行插入操作（如果链表为空，直接设置头节点为新添加的节点，否则设置尾节点的后一个节点为新添加的节点）
        04从头部进行删除操作（判断头节点是否有下一个节点，如果没有则设置节点为null）
    ch06：双向链表
        01什么是双向链表：每一个节点除了保存了对下一个节点的引用，同时还保存对前一个节点的引用。
        02从头部进行插入（对链表进行判断，如果为空设置尾节点为新添加的节点，如果不为空，还需设置头节点的前一个节点为新添加的节点）
        03从尾部进行插入（如果链表为空，则直接设置头节点为新添加的节点，否则设置尾节点的后一个节点为新添加的节点，同时设置新添加的节点的前一个节点为尾节点）
        04从头部进行删除（判断头节点是否有下一个节点，如果没有则设置为节点为null，否则设置头节点的下一个节点的previous为null）
    ch07：二叉树的基本概念（具有唯一的根节点、每个节点最多有两个孩子、每个节点之一一个父亲节点）
        01为什么使用二叉树：有序数组插入数据项和删除数据项太慢，链表查找数据慢。
        02构成树的条件：从根到任何节点有且只有一条路径
        03路径：从一个节点到另一个节点，所经历的节点排列成为路径。
        04根：树最上面的节点成为根节点，一个树只有一个根节点。
        05父节点：下面还有子节点
        06子节点：每一个节点都有一条向下连接到另一个节点，下面的节点就是该节点的子节点。
        07叶子节点：没有子节点的节点成为叶子节点。
        08子树：子节点的子节点组合在一起就是一个子树。
        09访问：查看节点的数据项。
        10层：从根开始到这个节点有多少代。
        11：优点缺点：插入数据、删除数据和查找太快
    ch08：二叉树的基本操作
        01插入节点：从根节点开始查找一个相对应的节点，这个节点将成为新插入节点的父节点。当父节点找到后，判断新节点的值比父节点的值的大小决定是左节点还是右节点。
        02查找节点：从根节点开始查找，如果查找的节点值比当前节点的值小，则继续查找其左节点，否则查找右节点。
    ch09：遍历二叉树
        01遍历二叉树：遍历树是根据一个特定的顺序访问树的每一个节点，根据顺序分为：前序、中序、后序。
        02前序遍历：访问根节点；前序遍历左子树；前序遍历右子树
        03中序遍历：中序遍历左子树；访问根节点；中序遍历右子树
        04后续遍历：后续遍历左子树；后续遍历右子树；访问根节点
    ch10：删除二叉树节点
        01如何删除：删除之前先查找要删除的节点，找到节点后，这个要删除的节点可以有三种情况：
            该节点是叶子节点，没有子节点（要删除叶子节点，只需要改变该节点的引用值，将指向该节点的引用值设置为null）
            该节点只有一个节点（改变父节点的引用，将其直接指向要删除节点的子节点）
            该节点有两个子节点（要删除两个子节点的节点，就需要使用它中序后继来替代该节点）
    ch11：红黑树
    ch12：哈希表
        01哈希表：哈希表是一种数据结构，它提供了快速插入操作和查找操作，是基于数组实现的。
        02哈希化：直接将关键字作为索引；将单词转换成索引（将字母转成ASCII，然后相加；幂的连乘；压缩可选值）
        03压缩后出现的问题：冲突，不能保证每个单词都映射到数组的空白单元（解决方法：开放地址值法；链地址法）
    ch13：开放地址法
        01什么是开放地址法：当冲突发生时，通过查找数组的空位，将数据填入，而不再用哈希函数得到。
    ch14：链（表）地址法
        01什么是链地址法：在哈希表每个单元设置链表，某个数据项的关键字还是像通常一样映射到哈希的单元中。
    ch15：HashMap和LinkHashMap
    ch16：图的基本概念
        01什么是图：图是一种和树相像的数据结构，通常有一个固定的形状，这是由物理或抽象问题来决定的。
        02邻接：如果两个顶点被同一条边连接，就称为两个顶点是邻接的。
        03路径：路径是从一个顶点到另一个顶点经过的边的序列。
        04连通图和非连通图：至少有一条路径可以连接所以顶点，那么这个图就是连通图。
        05有向图和无向图：有向图是有方向的，无向图是没有方向的。
        06带权图：在有些图中，边被赋予了一个权值，权值是一个数字，它可以代表两个顶点的物理距离或时间。
        07程序实现
    ch17：图的搜索
    ch18：图的最小生成树


第二部分：数据算法algorithm，解决问题的一种思路。
    算法的特性：输入/输出/又穷性/确定性/可行性
    算法的基本要求：正确性/可读性/健壮性/时间复杂度/空间复杂度
    算法没有做好的，只有最合适的！
    ch01：基本排序（冒泡排序、选择排序、插入排序）
    ch02：提升排序（希尔、快速、归并、堆）排序口诀：冒择路（入）兮（希尔）快归堆
    ch03：递归调用
    ch04：递归穷举
    ch05：贪心和分治
    ch06：动态规划与回溯
    
  注意：时间复杂度和空间复杂度